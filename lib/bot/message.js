'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _qtypes = require('qtypes');

var _qtypes2 = _interopRequireDefault(_qtypes);

var _partsOfSpeech = require('parts-of-speech');

var _partsOfSpeech2 = _interopRequireDefault(_partsOfSpeech);

var _natural = require('natural');

var _natural2 = _interopRequireDefault(_natural);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _lemmer = require('lemmer');

var _lemmer2 = _interopRequireDefault(_lemmer);

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _debugLevels = require('debug-levels');

var _debugLevels2 = _interopRequireDefault(_debugLevels);

var _nodeNormalizer = require('node-normalizer');

var _nodeNormalizer2 = _interopRequireDefault(_nodeNormalizer);

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

var _dict = require('./dict');

var _dict2 = _interopRequireDefault(_dict);

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _debugLevels2.default)('SS:Message');
var ngrams = _natural2.default.NGrams;

var patchList = function patchList(fullEntities, things) {
  var stopList = ['I'];

  things = things.filter(function (item) {
    return !(stopList.indexOf(item) !== -1);
  });

  for (var i = 0; i < fullEntities.length; i++) {
    for (var j = 0; j < things.length; j++) {
      var thing = things[j];
      if (fullEntities[i].indexOf(thing) > 0) {
        things[j] = fullEntities[i];
      }
    }
  }
  return things;
};

var cleanMessage = function cleanMessage(message) {
  message = message.replace(/\./g, ' ');
  message = message.replace(/\s,\s/g, ' ');
  // these used to be bursted but are not anymore.
  message = message.replace(/([a-zA-Z]),\s/g, '$1 ');
  message = message.replace(/"(.*)"/g, '$1');
  message = message.replace(/\s"\s?/g, ' ');
  message = message.replace(/\s'\s?/g, ' ');
  message = message.replace(/\s?!\s?/g, ' ');
  message = message.replace(/\s?!\s?/g, ' ');
  return message;
};

// The message could be generated by a reply or raw input
// If it is a reply, we want to save the ID so we can filter them out if said again

var Message = function () {
  /**
   * Creates a new Message object.
   * @param {String} message - The cleaned message.
   * @param {Object} options - The parameters.
   * @param {String} options.original - The original message text.
   * @param {Object} options.factSystem - The fact system to use.
   * @param {String} [options.replyId] - If the message is based on a reply.
   * @param {String} [options.clearConversation] - If you want to clear the conversation.
   */
  function Message(message, options) {
    _classCallCheck(this, Message);

    debug.verbose('Creating message from string: ' + message);

    this.id = _utils2.default.genId();

    // If this message is based on a Reply.
    if (options.replyId) {
      this.replyId = options.replyId;
    }

    if (options.clearConversation) {
      this.clearConversation = options.clearConversation;
    }

    this.factSystem = options.factSystem;
    this.createdAt = new Date();

    // This version of the message is `EXACTLY AS WRITTEN` by the user
    this.original = message;
    this.raw = _nodeNormalizer2.default.clean(message).trim();
    this.clean = cleanMessage(this.raw).trim();
    debug.verbose('Message before cleaning: ', message);
    debug.verbose('Message after cleaning: ', this.clean);

    this.props = {};

    var words = new _partsOfSpeech2.default.Lexer().lex(this.clean);
    // This is used in the wordnet plugin (removing it will break it!)
    this.words = words;

    // This is where we keep the words
    this.dict = new _dict2.default(words);

    words = _math2.default.convertWordsToNumbers(words);
    this.taggedWords = new _partsOfSpeech2.default.Tagger().tag(words);
  }

  _createClass(Message, [{
    key: 'finishCreating',
    value: function finishCreating(callback) {
      var _this = this;

      this.lemma(function (err, lemWords) {
        if (err) {
          console.log(err);
        }

        _this.lemWords = lemWords;
        _this.lemString = _this.lemWords.join(' ');

        _this.posWords = _this.taggedWords.map(function (hash) {
          return hash[1];
        });
        _this.posString = _this.posWords.join(' ');

        _this.dict.add('lemma', _this.lemWords);
        _this.dict.add('pos', _this.posWords);

        // Classify Question
        _this.questionType = _qtypes2.default.questionType(_this.clean);
        _this.questionSubType = _qtypes2.default.classify(_this.lemString);
        _this.isQuestion = _qtypes2.default.isQuestion(_this.raw);

        // TODO: This is currently unused - why?
        // Sentence Sentiment
        _this.sentiment = 0;

        // Get Nouns and Noun Phrases.
        _this.nouns = _this.fetchNouns();
        _this.names = _this.fetchComplexNouns('names');

        // A list of terms
        // this would return an array of thems this are a, b and c;
        // Helpful for choosing something when the qSubType is CH
        _this.list = _this.fetchList();
        _this.adjectives = _this.fetchAdjectives();
        _this.adverbs = _this.fetchAdverbs();
        _this.verbs = _this.fetchVerbs();
        _this.pronouns = _this.pnouns = _this.fetchPronouns();
        _this.compareWords = _this.fetchCompareWords();
        _this.numbers = _this.fetchNumbers();
        _this.compare = _this.compareWords.length !== 0;
        _this.date = _this.fetchDate();

        _this.names = _lodash2.default.uniq(_this.names, function (name) {
          return name.toLowerCase();
        });

        // Nouns with Names removed.
        var lowerCaseNames = _this.names.map(function (name) {
          return name.toLowerCase();
        });

        _this.cNouns = _lodash2.default.filter(_this.nouns, function (item) {
          return !_lodash2.default.includes(lowerCaseNames, item.toLowerCase());
        });

        _this.checkMath();

        // Things are nouns + complex nouns so
        // turkey and french fries would return ['turkey','french fries']
        // this should probably run the list though concepts or something else to validate them more
        // than NN NN etc.
        _this.fetchNamedEntities(function (entities) {
          var complexNouns = _this.fetchComplexNouns('nouns');
          var fullEntities = entities.map(function (item) {
            return item.join(' ');
          });

          _this.entities = patchList(fullEntities, complexNouns);
          _this.list = patchList(fullEntities, _this.list);

          debug.verbose('Message: ', _this);
          callback(_this);
        });
      });
    }

    // We only want to lemmatize the nouns, verbs, adverbs and adjectives.

  }, {
    key: 'lemma',
    value: function lemma(callback) {
      var itor = function itor(hash, next) {
        var word = hash[0].toLowerCase();
        var tag = _utils2.default.pennToWordnet(hash[1]);

        // console.log(word, tag);
        // next(null, [word]);

        if (tag) {
          try {
            _lemmer2.default.lemmatize(word + '#' + tag, next);
          } catch (e) {
            console.log('Caught in Excption', e);
            // This is probably because it isn't an english word.
            next(null, [word]);
          }
        } else {
          // Some words don't have a tag ie: like, to.
          next(null, [word]);
        }
      };

      _async2.default.map(this.taggedWords, itor, function (err, lemWords) {
        var result = _lodash2.default.map(_lodash2.default.flatten(lemWords), function (lemWord) {
          return lemWord.split('#')[0];
        });
        callback(err, result);
      });
    }
  }, {
    key: 'checkMath',
    value: function checkMath() {
      var numCount = 0;
      var oppCount = 0;

      for (var i = 0; i < this.taggedWords.length; i++) {
        if (this.taggedWords[i][1] === 'CD') {
          numCount += 1;
        }
        if (this.taggedWords[i][1] === 'SYM' || _math2.default.mathTerms.indexOf(this.taggedWords[i][0]) !== -1) {
          // Half is a number and not an opp
          if (this.taggedWords[i][0] === 'half') {
            numCount += 1;
          } else {
            oppCount += 1;
          }
        }
      }

      // Augment the Qtype for Math Expressions
      this.numericExp = numCount >= 2 && oppCount >= 1;
      this.halfNumericExp = numCount === 1 && oppCount === 1;

      if (this.numericExp || this.halfNumericExp) {
        this.questionType = 'NUM:expression';
        this.isQuestion = true;
      }
    }
  }, {
    key: 'fetchCompareWords',
    value: function fetchCompareWords() {
      return this.dict.fetch('pos', ['JJR', 'RBR']);
    }
  }, {
    key: 'fetchAdjectives',
    value: function fetchAdjectives() {
      return this.dict.fetch('pos', ['JJ', 'JJR', 'JJS']);
    }
  }, {
    key: 'fetchAdverbs',
    value: function fetchAdverbs() {
      return this.dict.fetch('pos', ['RB', 'RBR', 'RBS']);
    }
  }, {
    key: 'fetchNumbers',
    value: function fetchNumbers() {
      return this.dict.fetch('pos', ['CD']);
    }
  }, {
    key: 'fetchVerbs',
    value: function fetchVerbs() {
      return this.dict.fetch('pos', ['VB', 'VBN', 'VBD', 'VBZ', 'VBP', 'VBG']);
    }
  }, {
    key: 'fetchPronouns',
    value: function fetchPronouns() {
      return this.dict.fetch('pos', ['PRP', 'PRP$']);
    }
  }, {
    key: 'fetchNouns',
    value: function fetchNouns() {
      return this.dict.fetch('pos', ['NN', 'NNS', 'NNP', 'NNPS']);
    }

    // Fetch list looks for a list of items
    // a or b
    // a, b or c

  }, {
    key: 'fetchList',
    value: function fetchList() {
      debug.verbose('Fetch list');
      var list = [];
      if (/NNP? CC(?:\s*DT\s|\s)NNP?/.test(this.posString) || /NNP? , NNP?/.test(this.posString) || /NNP? CC(?:\s*DT\s|\s)JJ NNP?/.test(this.posString)) {
        var sn = false;
        for (var i = 0; i < this.taggedWords.length; i++) {
          if (this.taggedWords[i + 1] && (this.taggedWords[i + 1][1] === ',' || this.taggedWords[i + 1][1] === 'CC' || this.taggedWords[i + 1][1] === 'JJ')) {
            sn = true;
          }
          if (this.taggedWords[i + 1] === undefined) {
            sn = true;
          }
          if (sn && _utils2.default.isTag(this.taggedWords[i][1], 'nouns')) {
            list.push(this.taggedWords[i][0]);
            sn = false;
          }
        }
      }
      return list;
    }
  }, {
    key: 'fetchDate',
    value: function fetchDate() {
      var date = null;
      var months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];

      // http://rubular.com/r/SAw0nUqHJh
      var regex = /([a-z]{3,10}\s+[\d]{1,2}\s?,?\s+[\d]{2,4}|[\d]{2}\/[\d]{2}\/[\d]{2,4})/i;
      var match = this.clean.match(regex);

      if (match) {
        debug.verbose('Date: ', match);
        date = (0, _moment2.default)(Date.parse(match[0]));
      }

      if (this.questionType === 'NUM:date' && date === null) {
        debug.verbose('Try to resolve date');
        // TODO, in x months, x months ago, x months from now
        if (_lodash2.default.includes(this.nouns, 'month')) {
          if (this.dict.includes('next')) {
            date = (0, _moment2.default)().add('M', 1);
          }
          if (this.dict.includes('last')) {
            date = (0, _moment2.default)().subtract('M', 1);
          }
        } else if (_utils2.default.inArray(this.nouns, months)) {
          // IN month vs ON month
          var p = _utils2.default.inArray(this.nouns, months);
          date = (0, _moment2.default)(this.nouns[p] + ' 1', 'MMM D');
        }
      }

      return date;
    }

    // Pulls concepts from the bigram DB.

  }, {
    key: 'fetchNamedEntities',
    value: function fetchNamedEntities(callback) {
      var _this2 = this;

      var bigrams = ngrams.bigrams(this.taggedWords);

      var sentenceBigrams = _lodash2.default.map(bigrams, function (bigram) {
        return _lodash2.default.map(bigram, function (item) {
          return item[0];
        });
      });

      var itor = function itor(item, cb) {
        var bigramLookup = { subject: item.join(' '), predicate: 'isa', object: 'bigram' };
        _this2.factSystem.db.get(bigramLookup, function (err, res) {
          if (err) {
            debug.error(err);
          }

          if (!_lodash2.default.isEmpty(res)) {
            cb(err, true);
          } else {
            cb(err, false);
          }
        });
      };

      _async2.default.filter(sentenceBigrams, itor, function (err, res) {
        callback(res);
      });
    }

    // This function will return proper nouns and group them together if they need be.
    // This function will also return regular nonus or common nouns grouped as well.
    // Rob Ellis and Brock returns ['Rob Ellis', 'Brock']
    // @tags - Array, Words with POS [[word, pos], [word, pos]]
    // @lookupType String, "nouns" or "names"

  }, {
    key: 'fetchComplexNouns',
    value: function fetchComplexNouns(lookupType) {
      var tags = this.taggedWords;
      var bigrams = ngrams.bigrams(tags);
      var tester = void 0;

      // TODO: Might be able to get rid of this and use this.dict to get nouns/proper names
      if (lookupType === 'names') {
        tester = function tester(item) {
          return item[1] === 'NNP' || item[1] === 'NNPS';
        };
      } else {
        tester = function tester(item) {
          return item[1] === 'NN' || item[1] === 'NNS' || item[1] === 'NNP' || item[1] === 'NNPS';
        };
      }

      var nouns = _lodash2.default.filter(_lodash2.default.map(tags, function (item) {
        return tester(item) ? item[0] : null;
      }), Boolean);

      var nounBigrams = ngrams.bigrams(nouns);

      // Get a list of term
      var neTest = _lodash2.default.map(bigrams, function (bigram) {
        return _lodash2.default.map(bigram, function (item) {
          return tester(item);
        });
      });

      // TODO: Work out what this is
      var thing = _lodash2.default.map(neTest, function (item, key) {
        return _lodash2.default.every(item, _lodash2.default.identity) ? bigrams[key] : null;
      });

      // Return full names from the list
      var fullnames = _lodash2.default.map(_lodash2.default.filter(thing, Boolean), function (item) {
        return _lodash2.default.map(item, function (item2) {
          return item2[0];
        }).join(' ');
      });

      debug.verbose('Full names found from lookupType ' + lookupType + ': ' + fullnames);

      var x = _lodash2.default.map(nounBigrams, function (item) {
        return _lodash2.default.includes(fullnames, item.join(' '));
      });

      // FIXME: This doesn't do anything (result not used)
      // Filter X out of the bigrams or names?
      _lodash2.default.filter(nounBigrams, function (item, key) {
        if (x[key]) {
          // Remove these from the names
          nouns.splice(nouns.indexOf(item[0]), 1);
          nouns.splice(nouns.indexOf(item[1]), 1);
          return nouns;
        }
      });

      return nouns.concat(fullnames);
    }
  }], [{
    key: 'createMessage',
    value: function createMessage(message, options, callback) {
      if (!message) {
        debug.verbose('Message received was empty, callback immediately');
        return callback({});
      }

      var messageObj = new Message(message, options);
      messageObj.finishCreating(callback);
    }
  }]);

  return Message;
}();

exports.default = Message;